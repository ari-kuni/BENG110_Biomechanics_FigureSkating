import json
from pathlib import Path
import numpy as np
import pandas as pd

# ============================================================
# CONFIG
# ============================================================
ROOT = Path("JSON")          # root folder with Skater_A, Skater_B, ...
OUTDIR = Path("angles_output")
OUTDIR.mkdir(exist_ok=True)

MASS_KG = 55.0               # assumed skater mass (can change per-skater later)
G = 9.81                     # m/s^2

# landing/settle detection tuning
VEL_SMOOTH_WINDOW = 5     # frames for smoothing vz
SETTLE_VEL_THRESH = 0.3   # m/s, "settled" when |vz| below this
SETTLE_CONSEC = 10        # consecutive frames below thresh
FALLBACK_LANDING_S = 0.6  # if settle not found, use this many seconds after impact

# ============================================================
# HELPERS
# ============================================================
def load_json(path: Path):
    with open(path, "r") as f:
        return json.load(f)

def list_marker_names(j):
    return [m.get("Name") for m in j.get("Markers", [])]

def get_marker_array(j, name):
    """Return Nx3 array for marker 'name' or None if missing."""
    for m in j.get("Markers", []):
        if m.get("Name") == name:
            vals = m["Parts"][0]["Values"]
            arr = np.asarray(vals, dtype=float)
            if arr.ndim == 2 and arr.shape[1] >= 3:
                return arr[:, :3]
    return None

def get_first_existing_marker(j, candidates):
    """Try each name in candidates; return (name, Nx3 arr) for first found."""
    for nm in candidates:
        arr = get_marker_array(j, nm)
        if arr is not None:
            return nm, arr
    return None, None

def angle_ABC(A, B, C):
    """
    Angle at B formed by BA and BC.
    A,B,C are Nx3 arrays.
    Returns N angles in degrees.
    """
    BA = A - B
    BC = C - B
    ba_n = np.linalg.norm(BA, axis=1)
    bc_n = np.linalg.norm(BC, axis=1)
    denom = ba_n * bc_n
    denom[denom == 0] = np.nan
    cosang = np.sum(BA * BC, axis=1) / denom
    cosang = np.clip(cosang, -1.0, 1.0)
    ang = np.degrees(np.arccos(cosang))
    return ang

def smooth(x, w=5):
    if w <= 1:
        return x
    return pd.Series(x).rolling(w, center=True, min_periods=1).mean().to_numpy()

def compute_timebase(j, n_frames):
    freq = j.get("Timebase", {}).get("Frequency", 60.0)
    dt = 1.0 / float(freq)
    t = np.arange(n_frames) * dt
    return t, dt, freq

def estimate_pelvis_z(j):
    """
    COM-ish vertical position for landing detection.
    Prefer PELVIS. Else C_HIP. Else average of LHIP/RHIP. Else LASI/RASI.
    Returns z (N,) and n_frames.
    """
    candidates_primary = ["PELVIS", "C_HIP"]
    nm, arr = get_first_existing_marker(j, candidates_primary)
    if arr is not None:
        return arr[:, 2], arr.shape[0]

    lh = get_marker_array(j, "LHIP")
    rh = get_marker_array(j, "RHIP")
    if lh is not None and rh is not None:
        z = 0.5 * (lh[:, 2] + rh[:, 2])
        return z, lh.shape[0]

    la = get_marker_array(j, "LASI")
    ra = get_marker_array(j, "RASI")
    if la is not None and ra is not None:
        z = 0.5 * (la[:, 2] + ra[:, 2])
        return z, la.shape[0]

    all_names = list_marker_names(j)
    if not all_names:
        return None, 0
    arr_any = get_marker_array(j, all_names[0])
    return arr_any[:, 2], arr_any.shape[0]

def detect_landing_mask(j):
    """
    Landing = from impact (most negative vz) to settle (|vz|<thresh for consec frames).
    Returns boolean mask length N and (impact_idx, settle_idx).
    """
    pelvis_z, n_frames = estimate_pelvis_z(j)
    if pelvis_z is None or n_frames == 0:
        return None, None, None

    t, dt, freq = compute_timebase(j, n_frames)

    vz = np.gradient(pelvis_z, dt)
    vz_s = smooth(vz, VEL_SMOOTH_WINDOW)

    impact_idx = int(np.nanargmin(vz_s))

    abs_v = np.abs(vz_s)
    settle_idx = None
    for i in range(impact_idx, n_frames - SETTLE_CONSEC):
        if np.all(abs_v[i:i+SETTLE_CONSEC] < SETTLE_VEL_THRESH):
            settle_idx = i
            break

    if settle_idx is None:
        settle_idx = min(n_frames - 1, impact_idx + int(FALLBACK_LANDING_S * freq))

    mask = np.zeros(n_frames, dtype=bool)
    mask[impact_idx:settle_idx+1] = True
    return mask, impact_idx, settle_idx

def compute_landing_F_peak(j, impact_idx, settle_idx):
    """
    Estimate peak vertical GRF (F_peak) using impulse-momentum:

        F_peak = m * (|v_impact| / t_decel) + m*g

    where v_impact is vertical COM velocity at impact and t_decel is
    time from impact to settle.
    """
    pelvis_z, n_frames = estimate_pelvis_z(j)
    if pelvis_z is None or n_frames == 0:
        return np.nan, np.nan, np.nan

    t, dt, freq = compute_timebase(j, n_frames)

    vz = np.gradient(pelvis_z, dt)
    vz_s = smooth(vz, VEL_SMOOTH_WINDOW)

    v_impact = vz_s[impact_idx]             # m/s (negative = downward)
    t_decel = (settle_idx - impact_idx) * dt

    if t_decel <= 0:
        return v_impact, t_decel, np.nan

    F_peak = MASS_KG * (abs(v_impact) / t_decel) + MASS_KG * G  # Newtons
    return v_impact, t_decel, F_peak

def compute_lower_body_angles(j):
    """
    Auto-find markers and compute KNEE + ANKLE angles, vel, accel for all frames.
    Returns DataFrame with full-frame data and raw marker arrays for ankle/toe.
    """
    # ----- choose side: prefer Right, else Left -----
    hip_candidates_R = ["RHIP", "R_Hip Joint", "R_HIP"]
    knee_candidates_R = ["RKNE", "R_Knee", "RKNL", "RKNM"]
    ankle_candidates_R = ["RANK", "R_Ankle", "RANL", "RANM"]
    toe_candidates_R = ["R_Toe", "RTOE", "RMT5", "R_Toe Joint", "R_5th MTP Joint"]

    hip_candidates_L = ["LHIP", "L_Hip Joint", "L_HIP"]
    knee_candidates_L = ["LKNE", "L_Knee", "LKNL", "LKNM"]
    ankle_candidates_L = ["LANK", "L_Ankle", "LANL", "LANM"]
    toe_candidates_L = ["L_Toe", "LTOE", "LMT5", "L_Toe Joint", "L_5th MTP Joint"]

    hip_nm, hip = get_first_existing_marker(j, hip_candidates_R)
    knee_nm, knee = get_first_existing_marker(j, knee_candidates_R)
    ankle_nm, ankle = get_first_existing_marker(j, ankle_candidates_R)
    toe_nm, toe = get_first_existing_marker(j, toe_candidates_R)

    side = "R"
    if any(x is None for x in [hip, knee, ankle]):
        hip_nm, hip = get_first_existing_marker(j, hip_candidates_L)
        knee_nm, knee = get_first_existing_marker(j, knee_candidates_L)
        ankle_nm, ankle = get_first_existing_marker(j, ankle_candidates_L)
        toe_nm, toe = get_first_existing_marker(j, toe_candidates_L)
        side = "L"

    if hip is None or knee is None or ankle is None:
        raise ValueError(
            f"Missing required lower-body markers (hip/knee/ankle). "
            f"Found: hip={hip_nm}, knee={knee_nm}, ankle={ankle_nm}"
        )

    n_frames = hip.shape[0]
    t, dt, freq = compute_timebase(j, n_frames)

    # handle missing toe marker
    if toe is None:
        foot_candidates = (["RHEL", "R_HEEL", "RTOE", "RMT5"] if side == "R"
                           else ["LHEL", "L_HEEL", "LTOE", "LMT5"])
        toe_nm, toe = get_first_existing_marker(j, foot_candidates)
    if toe is None:
        toe = ankle + np.array([0.01, 0.0, 0.0])
        toe_nm = "toe_fallback"

    # ----- angles -----
    knee_angle = angle_ABC(hip, knee, ankle)
    ankle_angle = angle_ABC(knee, ankle, toe)

    # ----- angular velocity + acceleration -----
    knee_w = np.gradient(knee_angle, dt)
    ankle_w = np.gradient(ankle_angle, dt)

    knee_alpha = np.gradient(knee_w, dt)
    ankle_alpha = np.gradient(ankle_w, dt)

    df = pd.DataFrame({
        "frame": np.arange(n_frames),
        "time_s": t,

        "side_used": side,
        "hip_marker": hip_nm,
        "knee_marker": knee_nm,
        "ankle_marker": ankle_nm,
        "toe_marker": toe_nm,

        "knee_angle_deg": knee_angle,
        "ankle_angle_deg": ankle_angle,

        "knee_ang_vel_deg_s": knee_w,
        "ankle_ang_vel_deg_s": ankle_w,

        "knee_ang_accel_deg_s2": knee_alpha,
        "ankle_ang_accel_deg_s2": ankle_alpha,
    })

    # return marker arrays as well so we can get moment arm at impact
    return df, ankle, toe

def process_one_json(json_path: Path):
    """
    Return a ONE-ROW DataFrame with knee/ankle kinematics, F_peak, and ankle moment
    at the impact frame. If something fails, still return a row with NaNs + status.
    """
    j = load_json(json_path)

    base_row = {
        "frame": np.nan,
        "time_s": np.nan,
        "side_used": "",
        "hip_marker": "",
        "knee_marker": "",
        "ankle_marker": "",
        "toe_marker": "",
        "knee_angle_deg": np.nan,
        "ankle_angle_deg": np.nan,
        "knee_ang_vel_deg_s": np.nan,
        "ankle_ang_vel_deg_s": np.nan,
        "knee_ang_accel_deg_s2": np.nan,
        "ankle_ang_accel_deg_s2": np.nan,
        "impact_frame": np.nan,
        "settle_frame": np.nan,
        "decel_duration_s": np.nan,
        "landing_frame_rel": np.nan,
        "v_impact_m_s": np.nan,
        "F_peak_N": np.nan,
        "ankle_moment_Nm": np.nan,
        "status": "ok",
    }

    try:
        full_df, ankle_xyz, toe_xyz = compute_lower_body_angles(j)
    except Exception as e:
        base_row["status"] = f"angle_fail: {e}"
        return pd.DataFrame([base_row])

    mask, impact_idx, settle_idx = detect_landing_mask(j)
    if mask is None or impact_idx is None:
        base_row["status"] = "landing_detection_fail"
        return pd.DataFrame([base_row])

    # landing kinematics & F_peak
    v_impact, t_decel, F_peak = compute_landing_F_peak(j, impact_idx, settle_idx)

    # ankle moment:
    #   M_ankle = F_peak * r
    #   where r = horizontal distance ankle -> toe in the ice plane
    ankle_pt = ankle_xyz[impact_idx]
    toe_pt = toe_xyz[impact_idx]
    foot_vec = toe_pt - ankle_pt
    # horizontal distance in X-Y plane (assumes ice ~ horizontal)
    r = np.linalg.norm(foot_vec[:2])
    if np.isnan(F_peak) or np.isnan(r):
        ankle_moment = np.nan
    else:
        ankle_moment = F_peak * r  # N*m

    n_frames = len(full_df)
    _, dt, _ = compute_timebase(j, n_frames)

    row = full_df.loc[impact_idx].to_dict()
    row.update({
        "impact_frame": impact_idx,
        "settle_frame": settle_idx,
        "decel_duration_s": t_decel,
        "landing_frame_rel": 0,
        "v_impact_m_s": v_impact,
        "F_peak_N": F_peak,
        "ankle_moment_Nm": ankle_moment,
        "status": "ok",
    })

    return pd.DataFrame([row])

# ============================================================
# MAIN: all trials -> ONE CSV for ALL SKATERS
# ============================================================
def main():
    if not ROOT.exists():
        raise FileNotFoundError("JSON folder not found. Run from FSJ_Project root.")

    all_rows = []

    for skater_dir in sorted(ROOT.iterdir()):
        if not skater_dir.is_dir():
            continue
        skater_name = skater_dir.name

        for jump_dir in sorted(skater_dir.iterdir()):
            if not jump_dir.is_dir():
                continue
            jump_name = jump_dir.name

            for jf in sorted(jump_dir.glob("*.json")):
                trial_stem = jf.stem  # e.g., Axel_4
                land_df = process_one_json(jf)

                land_df.insert(0, "skater", skater_name)
                land_df.insert(1, "jump", jump_name)
                land_df.insert(2, "trial", trial_stem)

                all_rows.append(land_df)

    if all_rows:
        out_df = pd.concat(all_rows, ignore_index=True)
        out_csv = OUTDIR / "all_skaters_landing_lower_body_angles.csv"
        out_df.to_csv(out_csv, index=False)
        print(f"Saved {out_csv} ({len(out_df)} rows)")
        print("Status counts:\n", out_df["status"].value_counts())
    else:
        print("No JSON files found")

if __name__ == "__main__":
    main()

