import json
from pathlib import Path
import numpy as np
import pandas as pd

# ============================================================
# CONFIG (tune if you want)
# ============================================================
ROOT = Path("JSON")
OUTDIR = Path("angles_output")
OUTDIR.mkdir(exist_ok=True)

# landing/settle detection tuning
VEL_SMOOTH_WINDOW = 5     # frames for smoothing vz
SETTLE_VEL_THRESH = 0.3   # m/s, "settled" when |vz| below this
SETTLE_CONSEC = 10        # consecutive frames below thresh
FALLBACK_LANDING_S = 0.6  # if settle not found, use this many seconds after impact

# ============================================================
# HELPERS
# ============================================================
def load_json(path: Path):
    with open(path, "r") as f:
        return json.load(f)

def list_marker_names(j):
    return [m.get("Name") for m in j.get("Markers", [])]

def get_marker_array(j, name):
    """Return Nx3 array for marker 'name' or None if missing."""
    for m in j.get("Markers", []):
        if m.get("Name") == name:
            vals = m["Parts"][0]["Values"]
            arr = np.asarray(vals, dtype=float)
            if arr.ndim == 2 and arr.shape[1] >= 3:
                return arr[:, :3]
    return None

def get_first_existing_marker(j, candidates):
    """Try each name in candidates; return (name, Nx3 arr) for first found."""
    for nm in candidates:
        arr = get_marker_array(j, nm)
        if arr is not None:
            return nm, arr
    return None, None

def angle_ABC(A, B, C):
    """
    Angle at B formed by BA and BC.
    A,B,C are Nx3 arrays.
    Returns N angles in degrees.
    """
    BA = A - B
    BC = C - B
    # norms
    ba_n = np.linalg.norm(BA, axis=1)
    bc_n = np.linalg.norm(BC, axis=1)
    # avoid divide by zero
    denom = ba_n * bc_n
    denom[denom == 0] = np.nan
    cosang = np.sum(BA * BC, axis=1) / denom
    cosang = np.clip(cosang, -1.0, 1.0)
    ang = np.degrees(np.arccos(cosang))
    return ang

def smooth(x, w=5):
    if w <= 1:
        return x
    return pd.Series(x).rolling(w, center=True, min_periods=1).mean().to_numpy()

def compute_timebase(j, n_frames):
    freq = j.get("Timebase", {}).get("Frequency", 60.0)
    dt = 1.0 / float(freq)
    t = np.arange(n_frames) * dt
    return t, dt, freq

def estimate_pelvis_z(j):
    """
    COM-ish vertical position for landing detection.
    Prefer PELVIS. Else C_HIP. Else average of LHIP/RHIP. Else LASI/RASI.
    Returns z (N,) and n_frames.
    """
    candidates_primary = ["PELVIS", "C_HIP"]
    nm, arr = get_first_existing_marker(j, candidates_primary)
    if arr is not None:
        return arr[:, 2], arr.shape[0]

    # average hips
    lh = get_marker_array(j, "LHIP")
    rh = get_marker_array(j, "RHIP")
    if lh is not None and rh is not None:
        z = 0.5 * (lh[:, 2] + rh[:, 2])
        return z, lh.shape[0]

    # average ASIS
    la = get_marker_array(j, "LASI")
    ra = get_marker_array(j, "RASI")
    if la is not None and ra is not None:
        z = 0.5 * (la[:, 2] + ra[:, 2])
        return z, la.shape[0]

    # last resort: any marker
    all_names = list_marker_names(j)
    if not all_names:
        return None, 0
    arr_any = get_marker_array(j, all_names[0])
    return arr_any[:, 2], arr_any.shape[0]

def detect_landing_mask(j):
    """
    Landing = from impact (most negative vz) to settle (|vz|<thresh for consec frames).
    Returns boolean mask length N and (impact_idx, settle_idx).
    """
    pelvis_z, n_frames = estimate_pelvis_z(j)
    if pelvis_z is None or n_frames == 0:
        return None, None, None

    t, dt, freq = compute_timebase(j, n_frames)

    vz = np.gradient(pelvis_z, dt)  # m/s if z is meters
    vz_s = smooth(vz, VEL_SMOOTH_WINDOW)

    impact_idx = int(np.nanargmin(vz_s))  # most negative velocity

    # find settle start after impact
    abs_v = np.abs(vz_s)
    settle_idx = None
    for i in range(impact_idx, n_frames - SETTLE_CONSEC):
        if np.all(abs_v[i:i+SETTLE_CONSEC] < SETTLE_VEL_THRESH):
            settle_idx = i
            break

    if settle_idx is None:
        settle_idx = min(n_frames - 1, impact_idx + int(FALLBACK_LANDING_S * freq))

    mask = np.zeros(n_frames, dtype=bool)
    mask[impact_idx:settle_idx+1] = True
    return mask, impact_idx, settle_idx

def compute_lower_body_angles(j):
    """
    Auto-find markers and compute angles + ang vel/acc.
    Returns DataFrame with full-frame angles (not yet filtered).
    """
    # ----- choose side: prefer Right, else Left -----
    hip_candidates_R = ["RHIP", "R_Hip Joint", "R_HIP"]
    knee_candidates_R = ["RKNE", "R_Knee", "RKNL", "RKNM"]
    ankle_candidates_R = ["RANK", "R_Ankle", "RANL", "RANM"]
    toe_candidates_R = ["R_Toe", "RTOE", "RMT5", "R_Toe Joint", "R_5th MTP Joint"]

    hip_candidates_L = ["LHIP", "L_Hip Joint", "L_HIP"]
    knee_candidates_L = ["LKNE", "L_Knee", "LKNL", "LKNM"]
    ankle_candidates_L = ["LANK", "L_Ankle", "LANL", "LANM"]
    toe_candidates_L = ["L_Toe", "LTOE", "LMT5", "L_Toe Joint", "L_5th MTP Joint"]

    hip_nm, hip = get_first_existing_marker(j, hip_candidates_R)
    knee_nm, knee = get_first_existing_marker(j, knee_candidates_R)
    ankle_nm, ankle = get_first_existing_marker(j, ankle_candidates_R)
    toe_nm, toe = get_first_existing_marker(j, toe_candidates_R)

    side = "R"
    if any(x is None for x in [hip, knee, ankle]):
        # fallback to left
        hip_nm, hip = get_first_existing_marker(j, hip_candidates_L)
        knee_nm, knee = get_first_existing_marker(j, knee_candidates_L)
        ankle_nm, ankle = get_first_existing_marker(j, ankle_candidates_L)
        toe_nm, toe = get_first_existing_marker(j, toe_candidates_L)
        side = "L"

    if hip is None or knee is None or ankle is None:
        raise ValueError(f"Missing required lower-body markers (hip/knee/ankle). Found: hip={hip_nm}, knee={knee_nm}, ankle={ankle_nm}")

    n_frames = hip.shape[0]
    t, dt, freq = compute_timebase(j, n_frames)

    # trunk marker for hip angle (proximal point)
    trunk_candidates = ["C7", "CLAV", "Manubrium", "STERN", "C_ASIS", "PELVIS"]
    trunk_nm, trunk = get_first_existing_marker(j, trunk_candidates)
    if trunk is None:
        # hip angle fallback: use pelvis centroid from ASIS if possible
        z, _ = estimate_pelvis_z(j)
        trunk = hip.copy()
        trunk[:, 2] = z
        trunk_nm = "pelvis_fallback"

    # if toe missing, use ankle->foot direction via MT5 / heel etc.
    if toe is None:
        foot_candidates = (["RHEL","R_HEEL","RTOE","RMT5"] if side=="R"
                           else ["LHEL","L_HEEL","LTOE","LMT5"])
        toe_nm, toe = get_first_existing_marker(j, foot_candidates)
    if toe is None:
        # last resort: set toe = ankle + small forward vector so ankle angle doesn't crash
        toe = ankle + np.array([0.01, 0.0, 0.0])
        toe_nm = "toe_fallback"

    # ----- angles -----
    hip_angle = angle_ABC(trunk, hip, knee)
    knee_angle = angle_ABC(hip, knee, ankle)
    ankle_angle = angle_ABC(knee, ankle, toe)

    # ----- angular velocity + acceleration -----
    hip_w = np.gradient(hip_angle, dt)     # deg/s
    knee_w = np.gradient(knee_angle, dt)
    ankle_w = np.gradient(ankle_angle, dt)

    hip_alpha = np.gradient(hip_w, dt)     # deg/s^2
    knee_alpha = np.gradient(knee_w, dt)
    ankle_alpha = np.gradient(ankle_w, dt)

    df = pd.DataFrame({
        "frame": np.arange(n_frames),
        "time_s": t,

        "side_used": side,
        "hip_marker": hip_nm,
        "knee_marker": knee_nm,
        "ankle_marker": ankle_nm,
        "toe_marker": toe_nm,
        "trunk_marker": trunk_nm,

        "hip_angle_deg": hip_angle,
        "knee_angle_deg": knee_angle,
        "ankle_angle_deg": ankle_angle,

        "hip_ang_vel_deg_s": hip_w,
        "knee_ang_vel_deg_s": knee_w,
        "ankle_ang_vel_deg_s": ankle_w,

        "hip_ang_accel_deg_s2": hip_alpha,
        "knee_ang_accel_deg_s2": knee_alpha,
        "ankle_ang_accel_deg_s2": ankle_alpha,
    })
    return df

def process_one_json(json_path: Path):
    j = load_json(json_path)

    # compute full angles
    full_df = compute_lower_body_angles(j)

    # landing mask
    mask, impact_idx, settle_idx = detect_landing_mask(j)
    if mask is None:
        # if landing detection fails, just return empty
        return pd.DataFrame()

    land_df = full_df.loc[mask].copy()
    land_df["impact_frame"] = impact_idx
    land_df["settle_frame"] = settle_idx
    land_df["landing_frame_rel"] = land_df["frame"] - impact_idx
    return land_df

# ============================================================
# MAIN: all trials -> ONE CSV per skater
# ============================================================
def main():
    if not ROOT.exists():
        raise FileNotFoundError("JSON folder not found. Run from FSJ_Project root.")

    for skater_dir in sorted(ROOT.iterdir()):
        if not skater_dir.is_dir():
            continue

        skater_name = skater_dir.name
        all_rows = []

        for jump_dir in sorted(skater_dir.iterdir()):
            if not jump_dir.is_dir():
                continue
            jump_name = jump_dir.name

            for jf in sorted(jump_dir.glob("*.json")):
                trial_stem = jf.stem  # e.g., Axel_4
                try:
                    land_df = process_one_json(jf)
                    if land_df.empty:
                        continue

                    land_df.insert(0, "skater", skater_name)
                    land_df.insert(1, "jump", jump_name)
                    land_df.insert(2, "trial", trial_stem)

                    all_rows.append(land_df)

                except Exception as e:
                    print(f"Error in {jf}: {e}")

        if all_rows:
            out_df = pd.concat(all_rows, ignore_index=True)
            out_csv = OUTDIR / f"{skater_name}_landing_lower_body_angles.csv"
            out_df.to_csv(out_csv, index=False)
            print(f"Saved {out_csv} ({len(out_df)} landing frames)")
        else:
            print(f"No landing data found for {skater_name}")

if __name__ == "__main__":
    main()
